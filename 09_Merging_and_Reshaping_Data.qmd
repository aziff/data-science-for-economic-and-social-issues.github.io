---
title: "Merging and Reshaping Data"
---

Here are all the libraries you should install for this chapter. 

```{r eval=TRUE, warning = FALSE, message = FALSE}
library(dplyr)
library(readr)
library(tidyr)
```

## Merge: Built-in Functions

As discussed in [chapter 4](#chapter4), `rbind()` can be used to append additional observations. If using this approach, it is better to transform the new row(s) into a data frame. This will help avoid silently changing a variable type.
```{r, eval=TRUE}
df <- read.csv("Data/Gapminder/gapminder_large.csv")
str(df)
```
```{r, echo=FALSE}
names(df)[1] <- "COUNTRY"
names(df)
names(df)[2:3] <- c("GDP", "GINI")
names(df)
```

```{r, eval = FALSE}
df1 <- df[1:98, ]
df2 <- df[99:195, ]
rbind(df1, df2)
```

An even more robust approach is to use the `merge()` function. This allows for the two data frames to have different variables and similar observations. As long as there is at least one variable common to both data frames, they can be merged. Here is a very simple example.

```{r}
df1 <- df[1:5, c("COUNTRY", "region")]
df2 <- df[1:7, c("COUNTRY", "GDP", "GINI")]
merge(df1, df2, by = "COUNTRY")
```

Note that `df2` has 7 observations while `df1` only has 5. Yet, the output of the merge has 5 observations. This is because the arguments `all.x` and `all.y` are set to `FALSE` by default. This means that only rows that appear in both are present in the output. If we set `all.y = TRUE`, all the rows of `df2` are added with missing values for `region`.

```{r}
merge(df1, df2, by = "COUNTRY", all.y = TRUE)
```

If you want to keep all the rows in both data frames, the argument `all = TRUE` sets both `all.x = TRUE` and `all.y = TRUE`.

```{r}
merge(df1, df2, by = "COUNTRY", all = TRUE)
```

Suppose the variable you are merging on has different names in the two data frames. The arguments `by.x` and `by.y` allow for you to specify both variables.

```{r}
names(df1)[1] <- "country"
merge(df1, df2, by.x = "country", by.y = "COUNTRY")
```

If the two data frames have different variables with the same name, the merge will not combine these columns. This even applies if the columns are different types.

```{r}
df1 <- df[c("COUNTRY", "region", "GDP")]
df1$GDP <- as.character(df1$GDP) # GDP is now character in df1
merge(df1, df2, by = "COUNTRY")
```

## Merge: tidyverse functions

Merging data frames is useful when there are several data frames with similar observations but different variables. To demonstrate the join functions in `dplyr`, we have two datasets. One is the population of all countries and the other is the population of all countries that begin with "A." Neither of these datasets have duplicates.

```{r}
pop <- read_csv("Data/Gapminder/population.csv")
popA <- read_csv("Data/Gapminder/population_A.csv")
tib1 <- read_csv("Data/Gapminder/gapminder.csv")
str((tib1))
```

The different join functions relate to which observations are kept. In `full_join()`, all observations in the two data frames are kept, even if there are unmatched observations. The argument `by` indicates which variable on which to match.

```{r}
full_join(tib1, pop, by = "country")
```

The function `inner_join()` only keeps observations that are present in both data frames. In this case, that is only countries that begin with "A."

```{r}
inner_join(tib1, popA, by = "country")
```

The function `left_join()` only keeps from the data frame in the left argument (`tib1` in this case).

```{r}
left_join(tib1, popA, by = "country")
```

The function `right_join()` is the same except it only keeps the observations from the data frame in the right argument.

```{r}
right_join(tib1, popA, by = "country")
```

The function `semi_join()` keeps all rows in `tib1` that have a match in `popA`.

```{r}
semi_join(tib1, popA, by = "country")
```

The function `anti_join()` keeps all rows in `tib1` that do not have a match in `popA`.

```{r}
anti_join(tib1, popA, by = "country")
```

## Reshape: `tidyr`

The `tidyr` package provides an efficient way to reshape and reformat data.

```{r}
tib1 <- read_csv("Data/Gapminder/gapminder_large.csv")
head(tib1)
```

Wide data have one row per unit while long data have more than one row per unit. To convert wide data to long, use `pivot_longer()`. There are several different ways to get the same output.

```{r}
# Select columns using tidy-select
# Dictate pattern with names_sep
long_tib1 <- pivot_longer(tib1,
                       contains("_"),
                       names_to = c("var", "year"),
                       names_sep = "_")

# Select columns using column indices
pivot_longer(tib1,
             5:21,
             names_to = c("var", "year"),
             names_sep = "_")

# Dictate pattern with names_pattern
pivot_longer(tib1,
             5:21,
             names_to = c("var", "year"),
             names_pattern = "(.*)_(.*)")

```

To go from long data to wide, use `pivot_wider`. There are several options to dictate the names of the newly created variables.

```{r}
wide_tib1 <- pivot_wider(long_tib1,
                      names_from = c("var", "year"),
                      values_from = "value")
head(wide_tib1)
pivot_wider(long_tib1,
            names_from = c("var", "year"),
            values_from = "value",
            names_sep = ".")
```

It might be useful to reference this chapter on [strings and regular expressions](https://r4ds.had.co.nz/strings.html). There are many ways to represent different patterns in character strings, and a standardized approach exists to minimize the need to type out everything explicitly.

## Further Reading

The above information comes from chapters 5.1-5.3, 6, and 21 of @boehmke_data_2016, chapters 2.2.5 and 3 of @zamora_saiz_introduction_2020. 

### References
