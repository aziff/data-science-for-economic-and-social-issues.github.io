---
title: "Data Management"
---

In this chapter, we will go through the R functions needed for data management. The built-in R functions are useful tools and it is important to know their syntax. There are several packages that are widely used that are helpful to work with larger data, produce cleaner code, and be more efficient in data management. The suite of packages called `tidyverse` is especially common.

Here are all the libraries you should install for this chapter. Most of these are packages in `tidyverse`.

```{r eval = TRUE, warning = FALSE, message = FALSE}
library(dplyr)
library(ggplot2)
library(magrittr)
library(readr)
library(readxl)
library(stringr)
library(tidyr)
```

We will practice with imported data. Go to `Canvas > Modules > Module 1 > Data` for the example data. Download the entire folder `Gapminder` to a convenient file on your computer and save the file path for use in the below notes. Make sure that you have the folder unzipped and the correct path to the folder.

## Built-in Functions

### Select Variables

```{r}
df <- read.csv("Data/Gapminder/gapminder_large.csv")
str(df)
```

Take a moment to look at the data in the data viewer. It is useful to consider the following questions whenever loading data:

- How many rows and columns are there?
- What type of observation (e.g., countries, people, firms, households) do the rows represent? Another way to say this is: what is the unit of observation?
- Are the names of the variables convenient?

The built-in functions import data as data frames. Chapter 2 discusses how to select variables (columns). Here is a small review.

```{r, eval = FALSE}
df[, 1:3]
df[, c(2, 4)]
df[, "cpi_2017"]
df[, c("lifeexp_2012", "cpi_2016")]
df[c("country", "region")]
df[1:3]
df$gini_2015
```

### Rename and Create Variables

The names of a data frame can be access with `names()`. This is an attribute of the data frame and can be used to rename all the variables this way.

```{r}
names(df)
names(df) <- paste0("var", 1:length(names(df)))
names(df)
```

An alternative is to use the function `setNames()`. This function can also be used for other data structures besides data frames, such as vectors.

```{r}
vnames <- c("country", "gdp_2015", "gini_2015", "region",      
            "co2_2015", "co2_2016", "co2_2017", "co2_2018",   
            "cpi_2012", "cpi_2013", "cpi_2014", "cpi_2015",    
            "cpi_2016", "cpi_2017", "lifeexp_2012", "lifeexp_2013",
            "lifeexp_2014", "lifeexp_2015", "lifeexp_2016", "lifeexp_2017",
            "lifeexp_2018")
df <- setNames(df, vnames)
names(df)
```

It is also possible to rename a subset of the variables.

```{r}
names(df)[1] <- "COUNTRY"
names(df)
names(df)[2:3] <- c("GDP", "GINI")
names(df)
```

Creating new variables can be done with `cbind()` as discussed in chapter 2.

```{r}
random1 <- rnorm(dim(df)[1])
head(random1)
df <- cbind(df, random1)
df[1:5, c("COUNTRY", "random1")]
```

This method has the advantage that it can be used to add more than one variable at a time.

```{r}
random2 <- runif(dim(df)[1])
random3 <- rexp(dim(df)[1])
df <- cbind(df, random2, random3)
df[1:5, c("COUNTRY", "random2", "random3")]
```

The following shortcut is helpful to create one variable at a time.

```{r}
df$random4 <- df$random3^2
df[1:5, c("COUNTRY", "random4")]
```

### Filter Observations

Filtering observations can be done by row name or number, as shown in chapter 2.

```{r, eval = FALSE}
df[1:3, ]
df[c(3, 40), ]
df[c("4", "17"), ]
df[!c(1:190), ]
df[-c(1:190), ]
```

Filtering can also be done using logical statements.

```{r}
df[df$random2 >= 1, ]
df[df$random2 >= 1 & df$random3 <= 0.5, ]
subset(df, df$random3 <= 0.05)[, c("COUNTRY", "random3")]
```

The `which()` function returns the row numbers that are being filtered.

```{r}
which(df$random3 <= 0.05)
```

### Organize

Sorting can be done by one or more columns. Note that even though the rows are re-ordered, the original row names remain.

```{r}
dforder1 <- order(df$GINI)
head(df[dforder1, c("COUNTRY", "GINI")])
dforder2 <- order(df$region, df$GINI)
head(df[dforder2, c("COUNTRY", "region", "GINI")])
```


## `tidyverse` Functions

Hadley Wickham developed the idea behind a suite of packages that streamline data work called `tidyverse`. There are many packages in this suite that relate to different types of datasets and parts of the data process. This chapter goes through `dplyr`, `tidyr`, and `readr`.

### Import and Export: `readr`

The functions in the `readr` package to read and write data are faster than the built-in functions. Apart from efficiency, they have another advantage in that they help ensure consistency in the imported data. For example, if there are spaces in the variable name, `read.csv()`, the built-in function, will automatically remove these. The `readr` function `read_csv()` will not remove them.

```{r}
tib1 <- read_csv("Data/Gapminder/gapminder.csv")
str(tib1)
```

Immediately, you can see that the data structure is different. The package `readr`, and all the packages in the `tidyverse` suite, rely on a data structure called tibbles instead of data frames. The two main differences between tibbles and data frames are the following. More information on the differences is available [here](https://cran.r-project.org/web/packages/tibble/vignettes/tibble.html).

-   Unlike data frames, tibbles only show the first 10 rows and enough columns to fit on the screen. Each column is printed with its type.

-   When subsetting, `[]` always returns another tibble and `[[]]` always returns a vector.

Just like in `read.csv()`, you can specify the columns.

```{r}
tib2 <- read_csv("Data/Gapminder/gapminder.csv",
                 col_types = list(col_character(),
                                  col_integer(),
                                  col_double(),
                                  col_factor()))
str(tib2)
```

If you want to completely rename the columns, you can do so with the option `col_names`. You will just need to tell R to skip reading in the first line of the file.

```{r}
tib3 <- read_csv("Data/Gapminder/gapminder.csv", skip = 1,
                 col_names = c("V1", "V2", "V3", "V4"))
str(tib3)
```

The argument `n_max` determines the maximum number of lines that are read.

```{r}
read_csv("Data/Gapminder/gapminder.csv", n_max = 3)
```

The `readr` analogues to `read.table()` and `read.delim()` are `read_table()` and `read_delim()`. They have similar arguments as `read_csv()`. Reading in data files usually presents unexpected difficulties and complications, and the myriad of arguments available can help address any formatting issues automatically.

The write functions in `readr` are faster than the built-in functions and automatically omit row names.

```{r}
write_csv(df, file = "Data/Gapminder/Output_Data/df_csv_readr.csv")
```

#### Practice Exercises 

1.  Another way to list the column types is string shortcuts. For example `"d"` for double, `"c"` for character, etc. Check the documentation for `read_csv()`, and call in `"gapminder.csv"` with a character column, an integer column, a double column, and a factor column.
2.  You can also easily skip columns with this shorthand. Why do you think this be useful? Call in `"gapminder.csv"` again skipping the `Region` column.

### Transform: `dplyr`

The package `dplyr` includes functions that transform tibbles and data frames.

```{r}
df <- read_csv("Data/Gapminder/gapminder.csv")
head(df)
```

#### Select Variables

The general form of functions in `dplyr` involves identifying the data frame first and then specifying the options. To demonstrate, the function `select` chooses which variables.

```{r}
select(tib1, country)
```

Note that the original data frame is not changed. You will have to assign an object if you want to save this selection in an object.

```{r}
head(tib1)
```

There are several ways to select more than one variable. The last method used a helper, `starts_with()`. See the documentation for `select` for other helpers.

```{r, eval = FALSE}
select(tib1, country, gdp)
select(tib1, gdp:gini)
select(tib1, -gdp)
select(tib1, -c(country, gini))
select(tib1, starts_with("g"))
```

Sometimes it is desirable to rename variables when selecting them. This is very convenient in `select`!

```{r}
select(tib1, country_name = country)
select(tib1, var = starts_with("g"))
```

#### Rename and Create Variables

If you want to rename variables without dropping any, use the function `rename`.

```{r}
rename(tib1, country_name = country)
rename(tib1, country_name = country, gdp_percapita = gdp)
```

The function `mutate()` allows for new variables to be added to the data frame or existing variables to be modified without changing the other variables.

```{r}
mutate(tib1, gdp_sq = gdp^2)
mutate(tib1, row_id = 1:length(country))
mutate(tib1, gdp_large = ifelse(gdp >= 25000, TRUE, FALSE))
```

If you want to create a new variable and drop the other variables, use the function `transmute()`.

```{r}
transmute(tib1, gini_small = ifelse(gini <= 40, TRUE, FALSE))
```

#### Filter Observations

The function `select` allows you to choose which variables (columns) are included in your data. The function `filter` allows you choose which observations (rows) are included in your data.

```{r}
filter(tib1, region == "North America")
filter(tib1, is.na(gdp))
filter(tib1, gdp > 25000 & region != "Europe")
filter(tib1, region %in% c("North America", "Middle east"))
```

To select rows based on the number index, use `slice`.

```{r}
slice(tib1, 32:37)
```

The function `distinct()` filters out duplicated rows.

```{r}
distinct(tib1)
filter(tib1, duplicated(tib1)) # Check which observations are duplicated
```

The function `slice_sample()` randomly selects rows.

```{r}
slice_sample(tib1, n = 4)
slice_sample(tib1, prop = 0.03)
```

#### Organize

The functions so far produce data frames that explicitly differ from the inputted data frame. There are some silent functions that change the underlying structure without changing the outputted data frame. The function `group_by()` is an example of these silent functions. It groups the data based on the values of a set of variables. It makes most sense to group by categorical variables. The only difference is that now it says `Groups: region [7]`.

```{r}
group_tib1 <- group_by(tib1, region)
group_tib1
```

Ungrouping the data is another silent function and it removes this underlying grouping.

```{r}
ungroup(group_tib1)
```

The function `arrange` sorts the data based on the rank order of a set of variables. Adding `desc()` changes the rank-order to descending.

```{r}
arrange(tib1, gini)
arrange(tib1, desc(region), gini)
```

#### Practice Exercises 

1.  Before running this code, what do you think the output will be? Check to see if you were right!

```{r, eval=FALSE}
anti_join(popA, tib1, by = "country")
```

## Pipes

The `magrittr` package contains the pipe operator, `%>%`. The purpose of this operator is to make code clearer and more efficient. The idea is to minimize unnecessary saved objects. For example, if you are cleaning a dataset, it would be cumbersome to save a new data frame for each step in the cleaning process. Pipe operators, or pipes, help with this.

The idea is that the pipe forwards a value to the next function. The two lines result in the same output. The first argument of `filter()` is forwarded by the pipe operator.

```{r}
filter(tib1, region == "North America")
tib1 %>% filter(region == "North America")
```

Pipe operators are especially useful when there are several operations being applied to the same object.
```{r, echo=FALSE}
pop <- read_csv("Data/Gapminder/population.csv")
popA <- read_csv("Data/Gapminder/population_A.csv")
```

```{r}
tib1 %>%
  distinct() %>%
  full_join(pop, by = "country") %>%
  arrange(desc(region), desc(population)) %>%
  head()
```

To highlight the utility of pipe operators, consider these alternatives. They produce the same results. The first approach results in two objects that are not necessary for the final analysis, `tmp1` and `tmp2`. These objects are created with the sole purpose of being used in other functions. If the dataset is large, saving different versions of it can be burdensome. Additionally, the workspace becomes messy with so many temporary objects. While the second approach avoids temporary versions, it is difficult to read and understand.

```{r}
tmp1 <- distinct(tib1)
tmp2 <- full_join(tmp1, pop, by = "country")
df <- arrange(tmp2, desc(region), desc(population))
head(df)

head(arrange(distinct(full_join(tib1, pop, by = "country")), desc(region), desc(population)))
```

Note that the pipe operator can be used with functions outside of the `tidyverse` functions.

```{r}
full_join(df, pop, by = "country") %>%
  write.csv("Data/Gapminder/Output_Data/country_info.csv")
```

Pipe operators can forward objects to other arguments besides the first one. A period (`.`) indicates this. Here is an example with plotting (see chapter 7).

```{r, echo=FALSE}
tib1 <- read_csv("Data/Gapminder/gapminder_large.csv")
head(tib1)
```

```{r, fig.alt="Histogram of gini_2015 values with a peak around 40, showing distribution across countries."}
tib1 %>%
  distinct() %>%
  full_join(pop, by = "country") %>%
  ggplot(aes(x = gini_2015), data = .) + geom_histogram(stat = "bin")
```

Getting comfortable with `%>%` can vastly smooth your workflow in R. Another useful pipe is `%<>%` which functions the same as `%>%` but also assigns the object (it is called the assginment pipe). These two lines of code result in the same tibble.

```{r}
tib1 <- tib1 %>%
  mutate(id = 1:n())


tib1 %<>%
  mutate(id = 1:n())

```

### Practice Exercises 

1.  Use pipes to accomplish the following tasks on `tib1`: select `country`, `region`, `co2_2015`, and `co2_2016`, remove rows with missing values for either CO2 variables, create a variable that is `TRUE` when CO2 emissions in 2016 are smaller than those in 2015, and only keep the rows where this variable is `TRUE`.
2.  If you are curious, look at the documentation for `?magrittr`. There are four types of pipes. Take a moment to familiarize yourself with their differences.

## Further Reading

There are many great resources online, including cheat sheets. [Here](https://www.maths.usyd.edu.au/u/UG/SM/STAT3022/r/current/Misc/data-transformation.pdf) is one for `dplyr`. Save this cheat sheet if you find it useful! More cheat sheets can be found [here](https://www.rstudio.com/resources/cheatsheets/).

The above information comes from chapters 5.1-5.3, 6, and 21 of @boehmke_data_2016, chapters 2.2.5 and 3 of @zamora_saiz_introduction_2020. See @zamora_saiz_introduction_2020 chapter 3 for information on `data.table`.

### References
